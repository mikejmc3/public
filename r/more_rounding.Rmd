---
title: "More Rounding"
output: html_notebook
---

In my *rounding_sas_vs_r* SAS notebook (located in the sas folder), I compared rounding outcomes between SAS and R. The most noteworthy difference is that SAS always rounds ties up, while the `round` function in R rounds ties to the closest even value. Due to numerical precision complexities, however, unexpected outcomes can happen on occasion when using R's `round` function. For instance, rounding a value of 1.15 to the first decimal place should yield 1.2. This outcome would be expected under *either* tie-breaking rule, in fact. Instead, a value of 1.1 is returned.

```{r}
round(1.15, 1)
```
# Correcting Rounding Issues

Things like this happen because the way a floating point value is *stored* is not always perfectly identical to how it is *represented* for the user to see, and R's `round` function operates on the value *as it is stored*.

Alternatively, the `signif` function rounds values to a specified number of *significant digits*, which may yield results that better align outcomes with user expectations. Let's round this value again, but this time use the `signif` function and round based on *2 significant digits*.

```{r}
signif(1.15, 2)
```

Let's compare these two functions by rounding a set of numbers to the first decimal place. Our expectation is that all values should round to the nearest even value in the first decimal place. 

Side note: I am purposefully avoiding the `seq` function here because of differences in how certain floating point values are stored, depending on whether they are manually-entered by the user or are generated by a function like `seq`.

```{r}
x_vec <- c(1.05, 1.15, 1.25, 1.35, 1.45, 1.55, 1.65, 1.75, 1.85, 1.95)
x_round <- round(x_vec, 1)
x_signif <- signif(x_vec, 2)
x_df <- data.frame(cbind(x_vec, x_round, x_signif))
print(x_df)
```

As displayed above, the `round` function yields unexpected results for 1.15 and 1.85, while all outcomes from the `signif` function align with expectation of rounding to the nearest even first decimal place.

# Rounding All Ties Up

## Attempt 1

What if we want SAS-style rounding that always rounds ties up? Let's try this function I adapted from [datacornering.com](https://datacornering.com/round-roundup-rounddown-trunc-in-r/).

```{r}
round_up <- function (x, digits=0) {
    # Source: https://datacornering.com/round-roundup-rounddown-trunc-in-r/
    posneg = sign(x)
    z = trunc(abs(x) * 10 ^ (digits + 1)) / 10
    z = floor(z * posneg + 0.5) / 10 ^ digits
    return(z)
}
```

Let's compare this `round_up` function to our other rounding outcomes.

```{r}
x_df$x_ru <- round_up(x_vec, 1)
print(x_df)
```

This looks close, but rounding for value 1.15 once again is proving troublesome, as that rounded down to 1.1 when we expected it to round up to 1.2.

## Understanding the Issue

The root cause of this problem is that although $1.15 \times 100 = 115$ in the real world, they are not quite equal in R after all. Let's test this.

```{r}
# Should result in TRUE
115 == (1.15 * 100)
```

They are not equal, so let's calculate the difference.

```{r}
115 - (1.15 * 100)
```

In R, the product of `1.15 * 100` is actually 114.99999999999999. If we add 1e-14 (0.00000000000001) to the product, that should cover the difference, and they should be equal now.

```{r}
# Should result in TRUE
115 == (1.15 * 100 + 1e-14)
```
There is our explanation for the apparent rounding issue for 1.15. When we multiply 1.15 by 100, we don't get 115, we instead get 114.99999999999999, and when we truncate that value, we end up with 114, which then throws off the rounding formula. 

## Attempt 2

Let's add a bit of "fudge factor" into the a new rounding function and see if that improves things.

```{r}
round_up_fix <- function (x, digits=0) {
    posneg = sign(x)
    mult <- 10 ^ digits
    z = (floor(abs(x) * mult + 0.5 + 1e-14) / mult) * posneg
    return(z)
}
```

Let's compare this to the other results now.

```{r}
x_df$x_ru_fix <- round_up_fix(x_vec, 1)
print(x_df)
```

And for good measure, let's try a negative value too.

```{r}
round_up_fix(-1.15, 1)
```

# Conclusion

Once again, I have demonstrated that rounding is not a simple as it seems. If we stick within R's preferred "round to nearest even" framework, the `signif` function appears to work well. Attempts to build a do-it-yourself solution to match a SAS-like "always round ties up" rule surfaces some unexpected numerical precision pitfalls.
